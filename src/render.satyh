@require: gr
@import: ast

module GreenDeriveRender : sig

    val render-math : derivation-ast -> math
    val render-inline : context -> derivation-ast -> inline-boxes

end = struct

    type layout = (|
        left-padding: length;
        right-padding: length;
        inner-width: length;
    |)

    type render-intermediate-result = (|
        rendered: inline-boxes;
        layout: layout;
    |)

    % length list -> length
    let length-max lens =
        let max2 len1 len2 = if len1 <' len2 then len2 else len1 in
        lens |> List.fold-left max2 0pt

    % layout -> layout -> length
    let get-bar-width assumptions-layout conclusion-layout =
        length-max [assumptions-layout#inner-width; conclusion-layout#inner-width]

    % context -> inline-text -> length -> render-intermediate-result
    let render-bar-with-label ctx line label-text bar-width =
        let spacing = 2pt in

        let make-label ctx label-text =
            match label-text with
            | None -> inline-nil
            | Some text -> read-inline ctx text in
        
        let make-bar ctx line label bar-width =
            let thickness = 0.5pt in
            let gap = 2pt in
            
            let label = make-label ctx label-text in
            inline-graphics bar-width (thickness +' gap) gap (fun (x, y) -> (
                let barx = x +' (get-natural-width label) +' spacing in
                List.append
                [
                    Gr.text-rightward (x, y -' (get-axis-height ctx)) label;
                ]
                (line ctx (barx, y) bar-width thickness)
            )) in 

        let label = make-label ctx label-text in
        let bar = make-bar ctx line label bar-width in
        (|
            rendered = bar;
            layout   = (|
                left-padding  = (get-natural-width label) +' spacing;
                right-padding = 0pt;
                inner-width   = bar-width;
            |)
        |)

    let get-left-width med  = med#layout#left-padding +' (med#layout#inner-width *' 0.5)
    let get-right-width med = med#layout#right-padding +' (med#layout#inner-width *' 0.5)
    let get-aligned-left-width meds  = meds |> List.map get-left-width |> length-max
    let get-aligned-right-width meds = meds |> List.map get-right-width |> length-max

    % render-intermediate-result *3 -> render-intermediate-result
    let align-and-stack assumptions bar conclusion =
        % length -> render-intermediate-result -> inline-boxes
        let align-rendered lwidth med =
            let lmargin = lwidth -' (get-left-width med) in
            (inline-skip lmargin) ++ med#rendered ++ inline-fil in

        % render-intermediate-result list -> inline-boxes
        let align-and-stack-rendered meds =
            let left-width = get-aligned-left-width meds in
            line-stack-bottom (meds |> List.map (align-rendered left-width)) in

        % render-intermediate-result list -> render-intermediate-result -> layout
        let align-layout meds conclusion =
            let left-width  = get-aligned-left-width meds in
            let right-width = get-aligned-right-width meds in
            (|
                left-padding  = left-width -' (get-left-width conclusion);
                right-padding = right-width -' (get-right-width conclusion);
                inner-width   = conclusion#layout#inner-width;
            |) in

        let meds = [assumptions; bar; conclusion] in
        (|
            rendered = align-and-stack-rendered meds;
            layout   = align-layout meds conclusion;
        |)

    % context -> derivation-ast -> render-intermediate-result
    let render-conclusion ctx conclusion =
        let rendered = embed-math ctx conclusion in
        (|
            rendered = rendered;
            layout = (|
                left-padding  = 0pt;
                right-padding = 0pt;
                inner-width  = get-natural-width rendered;
            |)
        |)

    % context -> derivation-ast list -> render-intermediate-result
    let-rec render-assumptions ctx assumptions =
        let empty-med-result = (|
            rendered = inline-nil;
            layout = (|
                left-padding  = 0pt;
                right-padding = 0pt;
                inner-width   = 0pt;
            |)
        |) in

        let join-render-intermediate-result med-l med-r ladj _ =
            match ladj with
            | None -> med-r
            | Some _ -> 
                let spacing = 10pt in
                let new-rendered = med-l#rendered ++ (inline-skip spacing) ++ med-r#rendered in
                let new-inner-width = med-l#layout#inner-width +' med-l#layout#right-padding +' spacing +' med-r#layout#left-padding +' med-r#layout#inner-width in
                (|
                    rendered = new-rendered;
                    layout = (|
                        left-padding = med-l#layout#left-padding;
                        right-padding = med-r#layout#right-padding;
                        inner-width = new-inner-width;
                    |)
                |) in
                assumptions
                |> List.map (render ctx)
                |> List.fold-left-adjacent join-render-intermediate-result empty-med-result

    % context -> derivation-ast -> inline-boxes
    and render ctx ast =
        match ast with
        | Ast(label, conclusion, assumptions, line) ->
            let med-assumptions = render-assumptions ctx assumptions in
            let med-conclusion = render-conclusion ctx conclusion in
            let bar-width = get-bar-width med-assumptions#layout med-conclusion#layout in
            let med-bar = render-bar-with-label ctx line label bar-width in

            align-and-stack med-assumptions med-bar med-conclusion

    let render-inline ctx ast = (render ctx ast)#rendered

    let render-math ast = text-in-math MathInner (fun ctx -> (render-inline ctx ast))

end