@require: gr
@import: ast

module GreenDeriveRender : sig

    val render-math : derivation-ast -> math
    val render-inline : context -> derivation-ast -> inline-boxes

end = struct

    type layout = (|
        left-padding: length;
        right-padding: length;
        innder-width: length;
    |)

    type render-intermediate-result = (|
        rendered: inline-boxes;
        layout: layout;
    |)

    % context -> derivation-ast list -> render-intermediate-result
    let-rec render-assumptions ctx assumptions =
        let empty-med-result = (|
            rendered = inline-nil;
            layout = (|
                left-padding  = 0pt;
                right-padding = 0pt;
                inner-width   = 0pt;
            |)
        |) in

        let join-render-intermediate-result med-l med-r =
            let spacing = 30pt in
            let new-rendered = med-l#rendered ++ (inline-skip spacing) ++ med-r#rendered in
            let new-inner-width = med-l#inner-width +' med-l#right-padding +' spacing +' med-r#left-padding +' med-r#innder-width in
            (|
                rendered = new-rendered;
                layout = (|
                    left-padding = med-l#left-padding;
                    right-padding = med-r#right-padding;
                    inner-width = new-inner-width;
                |)
            |) in

        assumptions
        |> List.map (render ctx)
        |> List.fold-left-adjacent join-render-intermediate-result empty-med-result    


    % context -> derivation-ast -> render-intermediate-result
    and render-conclusion ctx conclusion =
        let rendered = embed-math ctx conclusion in
        (|
            rendered = rendered;
            layout = (|
                left-padding  = 0pt;
                right-padding = 0pt;
                innder-width  = get-natural-width rendered;
            |)
        |)

    % context -> derivation-ast -> inline-boxes
    and render ctx ast =
        match ast with
        | Ast(label, conclusion, assumptions) ->
            let med-assumptions = render-assumptions ctx assumptions in
            let med-conclusion = render-conclusion ctx conclusion in
            let bar-width = get-bar-width med-assumptions#layout med-conclusion#layout in
            let med-bar = render-bar-with-label ctx label bar-width in

            align-and-stack med-assumptions med-bar med-conclusion


    let render-math ast = text-in-math MathInner (fun ctx -> (read-inline ctx ast))
    
    let render-inline ctx ast = (render ctx ast)#rendered
        
    % layout -> layout -> length
    let get-bar-width assumptions-layout conclusion-layout =
        length-max [assumptions-layout#innder-width; conclusion-layout#inner-width]

    % context -> inline-text -> length -> render-intermediate-result
    let render-bar-with-label ctx label bar-width =
        let make-label ctx label =
            match label with
            | None -> inline-nil
            | Some -> read-inline ctx label in
        
        let make-bar ctx bar-width =
            let color = get-text-color ctx in
            let thickness = 0.5pt in
            let gap = 2pt in
            inline-graphics bar-width (thickness +' gap) gap (fun (x, y) -> 
                [ fill color (Gr.rectangle (x, y) (x +' w, y +' thickness))]
            ) in

        let label = make-label ctx label in
        let bar = inline-graphics bar-width in
        (|
            rendered = label ++ bar;
            layout   = (|
                left-padding  = get-natural-width label;
                right-padding = 0pt;
                inner-width   = bar-width;
            |)
        |)

    % render-intermediate-result *3 -> render-intermediate-result
    let align-and-stack assumptions bar conclusion =
        let meds = [assumptions; bar; conclusion] in
        (|
            rendered = align-and-stack-rendered meds;
            layout   = align-layout meds conclusion;
        |)

    % render-intermediate-result list -> inline-boxes
    let align-and-stack-rendered meds =
        let left-width = get-aligned-left-width in
        line-stack-bottom (meds |> List.map (align-rendered left-width))
        
    % length -> render-intermediate-result -> inline-boxes
    let align-rendered lwidth med =
        let lmargin = lwidth - (get-left-width med) in
        (inline-skip lmargin) ++ med#rendered ++ inline-fil

    % render-intermediate-result list -> render-intermediate-result -> layout
    let align-layout meds conclusion =
        let left-width  = get-alinged-left-width meds in
        let right-width = get-alingned-right-width meds in
        (|
            left-padding  = left-width -' (get-left-padding conclusion);
            right-padding = right-width -' (get-right-padding conclusion);
            inner-width   = conclusion#inner-width
        |)

    let get-aligned-left-width meds =
        meds |> List.map left-width |> length-max

    let get-aligned-right-width meds =
        meds |> List.map right-width |> length-max

    let get-left-width med  = med#left-padding + (med#internal-width /' 2)
    let get-right-width med = med#right-padding + (med#internal-width /' 2)

    % length list -> length
    let length-max lens =
        lens |> List.fold-left-adjacent (fun (len1, len2) -> (
            if len1 <' len2 then len2 else len1
        )) 0


end